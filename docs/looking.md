# Looking

# Tip:
    系统接收的是按时间有序的固定频率的数据，不接受无序的以及非固定频率的规则数据

- [ ] engine 告警dsl语法处理模块

#### TODO

### 选择
 1 针对于持续事件， 如果中间丢失数据，那么怎么处理
   - 在 ``policies.json`` 中定义的continue事件是通过统计过去几分钟已经产生的告警事件数量来判断是否
     为持续事件，如果中间丢失数据，那么会造成持续事件的不触发，如果previous()是以时间分割取前一条数据，那么
     会重新触发开启事件（这个问题需要考虑）
   - 另一种方式为不再对比告警事件的数量，而严格卡某段时间，保证所查询的历史数据buffer长度必须包含持续事件
     需要参与计算的buffer，然后保证在查询的事件片内的所有事件都为某一类事件，此时previous函数所取的数据
     为上一条存在的数据，而不是通过时间取值
     
     这样的好处：1 数据丢失不影响正在执行的报警状态 2 可以自定义数据粒度，而不影响告警持续时间的准确性


Tip:
  1. 每一个dsl处理完后，不需要再次进行处理，只要保持每次的template即可
  2. 对于事件处理状态机， 对于所有的事件处理都是通用的，依旧是只需要初始化一次，然后供所有的事件处理使用
  3. 告警的处理是实时的，告警事件的确定需要分为两部，第一步：根据每条到来的数据，来计算这条事件所产生的告警
     状态，第二部：根据第一步产生的事件，发到状态机中计算，计算所产生的事件，这步产生的事件一定为状态机中的
     某个状态，也是我们对外产生的事件
  4. 保证同一个 ``key`` 发送到同一个partation， 这个可以保证在每个线程流中，只有一个线程消费同一 ``key``的
     数据，从而保证线程安全性
  5. 告警的计算有两个时间，一是告警原生事件的时间戳， 二是当前时刻的时间戳。 告警时间的产生所使用的时间
     戳需要在两者选其一，如果是使用当前时刻，那么当数据延迟时，可能会造成数据的误报（这个有待思考）
  6. 在发送邮件或发送webhook时，需要确保所发送的对象真实存在，防止由于地址编辑错误而造成不必要的发送
  7. 关于状态机的状态转化，如果其参考的是前一条事件（pervious(`event`),那么前一条事件的时间跨度是多少，是使用配置文件
     中设置的值，还是依赖于从规则中设置的值。即healthStatusEvent的for时间依赖于RawMetricEvent的处理时间
     
     

问题：
  1 同一集群的不同实例告警受级联影响，具有重复性
  2  告警太频繁，会是人疲惫
  3  多种途径对同一个告警起作用
  4  告警需要区分优先级
  
策略：
  1. 尽可能是按照集群为单位去告警
  2. 告警频率收敛，即多长时间进行一次告警
  3. 需要有不同时间段的不同告警方式设置
  
